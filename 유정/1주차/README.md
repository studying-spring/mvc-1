## Web Server, WAS

### Web Server

- HTTP 기반으로 동작 (공통)
- 정적 HTML, CSS, JS, 이미지 영상 등 정적 리소스 제공
- 예) NGINX, APACHE

### Web Application Server(WAS)

- HTTP 기반으로 동작 (공통)
- 프로그램 코드를 실행해서 애플리케이션 로직 수행
- 예) Tomcat

→ WAS가 애플리케이션 코드를 실행하는데 더 특화

### 웹 시스템 구성

❗️ WAS가 정적 리소스와 애플리케이션 로직을 모두 제공한다고 해서 WAS와 DB만으로 시스템 구성이 가능하다고 볼 수 없음

**Why?**

- WAS가 모든 것을 담당하게 되면 서버 과부하가 걸릴 수 있음
- 정적 리소스는 단순하고 싼데 비해 애플리케이션 로직은 복잡하고 비쌈
  따라서, 정적 리소스 때문에 애플리케이션 로직이 수행이 어려워지면 안됨
- WAS가 죽으면, 서버 오류가 났을 때 정적 리소스마저 전송을 하지 못하기 때문에 오류 화면 노출이 불가능해짐

👍🏻 Web Server + WAS + DB

- 웹 서버를 앞에 둬서 정적 리소스를 먼저 처리하고 동적인 로직이 필요할 때에는 WAS가 처리
- 역할에 따른 업무 분담이 가능해짐
- 효율적인 리소스 관리 - 필요에 맞게 서버를 증설시킬 수 있음
- 웹서버는 잘 죽지 않기 때문에 WAS나 DB에서 장애가 발생했을 때, 오류 화면 노출이 가능해짐

## 서블릿

Http 요청 하나를 위해서 WAS가 동작해야할 것들이 너무 많음

→ 여기서 중요한 비즈니스 로직만 짤 수 있도록 나머지는 서블릿이 자동화해줌

### 특징

- 클라이언트의 요청을 받고 내부 클래스에서 요청을 동작하여 결과를 반환
- HTTP 요청 정보를 편리하게 사용할 수 있는 HttpServletRequest
- HTTP 응답 정보를 편리하게 제공할 수 있는 HttpServletResponse
- Controller에 해당

### 동작구조

1. localhost:8080/hello 요청
2. WAS가 요청 메시지를 기반으로 Request와 Response 객체를 생성 후 서블릿 객체 helloServlet 호출
3. helloServlet 실행
4. Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용
5. 그 후 helloServlet이 리턴이 되면 Response 객체에 HTTP 응답 정보를 편리하게 입력
6. WAS는 Response 객체에 담겨 있는 내용으로 HTTP 응답 정보 생성
7. 웹 브라우저에 전달

### 서블릿 컨테이너

서블릿을 지원하는 WAS (ex. Tomcat)

- 서블릿 객체 생성, 초기화, 호출, 종료 등 서블릿의 생명주기를 관리함
- 서블릿 객체는 싱글톤으로 관리
    - 클라이언트로부터 무수히 많은 요청을 받게 되는데, 이때마다 객체를 새로 생성하는 것은 비효율적
    - 따라서 최초 로딩 시점에 서블릿 객체를 만들고, 이를 계속 재사용하는 방식
    - 모든 고객의 요청은 동일한 서블릿 객체 인스턴스에 접근하게 됨
    - 이때 공유 변수 사용을 주의해야 함!
    - 서블릿 컨테이너가 종료되면 그때 같이 종료가 됨

<aside>
❓ 싱글톤이란?
객체를 단 한번 생성해서 공유하는 것

</aside>

- JSP도 서블릿으로 변환되어서 사용
- 동시 요청을 우한 멀티 쓰레드 처리 지원

## 멀티 쓰레드

서블릿 객체는 누가 호출하는가! → 쓰레드

### 쓰레드

- 애플리케이션 로직을 하나하나 순차적으로 실행
- 한번에 하나의 코드 라인만 수행

❗️따라서 단일 쓰레드를 사용하면 큰일남

→ 다중 요청이 들어왔을 때, 첫 번째 요청에서 처리지연이 발생하게 되면 나머지 요청은 계속 대기상태가 되기 때문

그렇다면 요청이 들어올때마다 쓰레드를 생성하게 되면?

→ 동시 요청이 들어와도 처리할 수 있고, CPU, 메모리가 허용할 때까지 계속해서 생성하여 처리할 수 있음

**BUT**

- 쓰레드의 생성 비용은 비쌈 → 요청 때마다 생성하면 응답속도가 느려짐
- 쓰레드는 컨텍스트 스위칭 비용이 발생 (컨텍스트 스위칭 비용 : 코어 하나가 두 개의 쓰레드를 순차적으로 실행하여 다음 쓰레드로 넘어갈 때 발생하는 비용)
- 쓰레드 생성에 제한이 없으면 요청 수 만큼 계속 생성되고 CPU, 메모리 임계점을 넘어 서버가 죽음

위와 같은 단점을 극복하기 위해 나타난 것이 **쓰레드 풀**

### 쓰레드 풀

- 쓰레드 풀에 쓰레드를 모아놓고, 요청이 오면 풀에서 쓰레드를 받아 사용하고 다시 반환함
- 톰캣의 경우 최대 200개의 쓰레드로 풀 설정
- 만약 모든 쓰레드가 사용중이라면 새로 들어오는 요청은 거절하거나 특정 숫자만큼만 대기하도록 설정

→ 쓰레드가 미리 생성되어 있기 때문에 비용이 절약되고, 응답 시간이 빠름. 그리고 쓰레드의 최대치가 정해져 있기 때문에 많은 요청이 들어와도 기존 요청을 안전하게 처리할 수 있음

<aside>
💡 WAS에서의 주요 튜닝 포인트는 최대 쓰레드 개수를 어떻게 설정하는 것이지만, WAS가 알아서 멀티쓰레드를 처리해주고 우리는 멀티 쓰레드 관련 코드를 신경쓰지 않아도 됨..!

단, 싱글톤 객체(서블릿, 빈)은 주의해서 사용해야 함

</aside>

## CSR, SSR

### SSR - 서버사이드 렌더링

- html 최종 결과를 서버에서 만들어서 웹 브라우저에 전달
- 즉, 프론트에서 요청하면 HTML에 모든 결과를 담아 브라우저에 전달하는 것임
- JSP, Thymeleaf

### CSR - 클라이언트 사이드 렌더링

- Html 결과를 js를 이용해 웹 브라우저에서 동적으로 생성해서 적용
- 예를 들어 구글 지도에서 위치를 변경하거나 확대를 해도 url은 변하지 않음, 즉 필요한 부분을 js를 통해 동적으로 생성
- React, Vue.js